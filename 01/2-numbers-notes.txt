В Javascript все числа хранятся в 64-битном формате IEEE-754 или "числа с плавающей точкой двойной точности".

Есть несколько способов записи числа.

Большие числа можно написать как есть:

    let billion = 1000000000;

Или использовать сокращенную запись:

    let billion = 1e9; // умножаем 1 на 10^9 
    alert( 7.3e9 ); // выведет 7,300,000,000

Маленькие числа записываются похожим образом:

    alert( 1e-3 ); // умножаем 1 на 10^(-3), получится 0,001

Для десятичной системы счисления особая форма записи не нужна, для других же:

    alert( 0xff ); // Число 255 в 16-ричной системе счисления.
    alert( 0xFF ); // Регистр не важен, то же самое.

    alert( 0b11111111 ); // Число 255 в двоичной системе.
    alert( 0o377 ); // Число 255 в восьмеричной системе. 

Для других возможных систем счисления есть функция parseInt().

Функция toString(base) выводит строку с числом в системе счисления base:

    let num = 255;

    alert( num.toString(16) ); // FF
    alert( num.toString(2) ); // 11111111

Максимальное основание системы счисления - 36, так как задействуются все цифры и буквы латинского алфавита (0..9, A..Z).

Для того, чтобы не путать точку у числа и вызов метода у числа (не переменной) через точку, делается так:

    alert ( 123456..toString(36) ); // 2n9c


Часто используются различные варианты округления числа:

    alert( Math.floor(3.1) ); // Округление в меньшую сторону - 3
    alert( Math.floor(-1.1) ); // Округление в меньшую сторону - -2
    
    alert( Math.ceil(3.1) ); // Округление в большую сторону - 4
    alert( Math.ceil(-1.1) ); // Округление в большую сторону - -1
    
    alert( Math.round(3.1) ); // Округление до ближайшего целого - 3
    alert( Math.round(3.6) ); // Округление до ближайшего целого - 4
    alert( Math.round(-1.1) ); // Округление до ближайшего целого - -1
    
    alert( Math.trunc(3.1) ); // Отбрасывание дробной части - 3
    alert( Math.trunc(3.6) ); // Отбрасывание дробной части - 3
    alert( Math.trunc(-1.1) ); // Отбрасывание дробной части - -1. 
    
Math.trunc не поддерживается в Internet Explorer.

Если нужно округлить не до целого, а до количества цифр в дробной части, есть два способа:

    // Чтобы получить 2 знака после запятой, умножаем на 100, округляем и делим на 100.
    let num = 1.23456;
    alert( Math.floor(num * 100) / 100 ); // 1.23456 -> 123.456 -> 123 -> 1.23

    // Используем метод toFixed(n), который возвращает строку с числом с n знаков после запятой
    let num1 = 12.34;
    let num2 = 12.36;
    alert( num1.toFixed(1) ); // 12.3
    alert( num2.toFixed(1) ); // 12.4
    // Метод toFixed(n) округляет значение до ближайшего целого, аналогично Math.round()    
    // Если десятичная часть изначально короче, чем n, дописываются нули:
    alert( num1.toFixed(5) ); // 12.34000
    // Чтобы получить число, а не строку, используем унарный "+" или Number():
    +num1.toFixed(1);
    Number( num1.toFixed(1) );

Число хранится в 64-битном формате (см.выше). 52 бита отводится под цифры, 11 - для хранения положения десятичной точки (0 - если число целое) и 1 - для знака.
Если число не помещается в таком хранилище, вернется Infinity(бесконечность):

    alert( 1e500 ); //Infinity

При работе с дробными числами ВСЕГДА стоит иметь в виду потерю точности, ДАЖЕ если дробь конечная. 
Происходит это из-за того, что некоторые дроби типа 0.1 или 0.2 являются бесконечными дробями в двоичном формате. Если иметь в виду бесконечные дроби, то для
двоичной системы счисления 1/10 то же самое, что и 1/3 для десятичной.

В итоге получается такое:

    alert( 0.1 + 0.2 == 0.3 ); // false
    alert( 0.1 + 0.2 ); // 0.30000000000000004

IEEE-754 (см. выше) решает эту проблему округлением до ближайшего возможного числа. Но это число все равно имеет потерю точности, пусть даже почти незаметную:

    alert( 0.1.toFixed(20) ); // 0.10000000000000000555

Кроме Javascript, такая проблема существует, например, для PHP, Java, C, Perl, Ruby, так как они тоже используют IEEE-754.

Наиболее надежно решить проблему поможет метод toFixed(n), так как он возвращает строку, а не двоичное число:

    let sum = 0.1 + 0.2;
    alert( sum.toFixed(2) ); // 0.30

Превратить это в число можно унарным "+" или Number() как и выше, но вернется потеря точности.

Можно умножить дроби на 100 или больше, чтобы сделать их целыми, потом сложить и разделить результат. Это уменьшит погрешность, но не избавит от нее:

    alert( (0.1 * 10 + 0.2 * 10) / 10 ); // 0.3
    alert( (0.28 * 100 + 0.14 * 100) / 100); // 0.4200000000000001

Если целое число не помещается в 52 битах записи, то появляется забавный эффект:

    // Привет! Я – число, растущее само по себе!
    alert( 9999999999999999 ); // покажет 10000000000000000. Надо уточнить этот момент и записать сюда

Есть специальные числовые значения: Infinity, -Infinity и NaN (не число)

Функция isNaN() проверяет на не-число:

    alert( isNaN(NaN) ); // true
    alert( isNaN("str") ); // true

С помощью === проверить нельзя, так как NaN не равно вообще ничему, даже самому себе (????). 

    alert( NaN === NaN ); // false

Функция isFinite() проверяет, является ли число чем угодно, кроме NaN/Infinity/-Infinity:

    alert( isFinite("15") ); // true
    alert( isFinite("str") ); // false, потому что специальное значение: NaN
    alert( isFinite(Infinity) ); // false, потому что специальное значение: Infinity

Пустая строка в числовых функциях интерпретируется как 0.

Есть более точный способ сравнения двух значений, чем ===, это Object.is. В двух особых ситуациях он дает правильное значение:

    Object.is(NaN, NaN) === true;
    Object.is(0, -0) === false;

Унарный + или Number() вернут NaN, если используются не на точной записи числа:

    alert( +"100px" ); // NaN

В таком случае нужно использовать parseInt() для целых чисел и parseFloat() для дробных. Они возвращают число, которое успели прочитать до ошибки:

    alert( parseInt('100px') ); // 100
    alert( parseFloat('12.5em') ); // 12.5

    alert( parseInt('12.3') ); // 12, вернётся только целая часть
    alert( parseFloat('12.3.4') ); // 12.3, произойдёт остановка чтения на второй точке

    alert( parseInt('a123') ); // NaN, на первом символе происходит остановка чтения

У parseInt() есть второй аргумент, который позволяет перевести строку в нужную систему счисления (упомянуто выше):

    alert( parseInt('0xff', 16) ); // 255
    alert( parseInt('ff', 16) ); // 255, без 0x тоже работает

    alert( parseInt('2n9c', 36) ); // 123456

В Javascript встроен объект Math, который содержит разные математические функции и константы.

Например, Math.random() возвращает псевдослучайное число:

    alert( Math.random() ); // 0.1234567894322
    alert( Math.random() ); // ... (любое количество псевдослучайных чисел)
    alert( Math.floor( Math.random()*6 ) + 1 ); // бросок кубика

Мath.max(a, b, c, ...) и Math.min(a, b, c, ...) возвращают наибольшее/наименьшее значение:

    alert( Math.max(3, 5, -10, 0, 1) ); // 5
    alert( Math.min(1, 2) ); // 1

Math.pow(n, power) возводит n в степень power:

   alert( Math.pow(2, 10) ); // 2 в степени 10 = 1024

Есть множество других функций, включая тригонометрические.

