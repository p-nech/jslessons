# Строки

В Javascript любой текст имеет тип String. Отдельного типа char для символов нет (и Symbol не для этого).

Внутренний формат для всех строк - UTF-16 вне зависимости от кодировки страницы.

## Кавычки

Есть разные типы кавычек для строк - '', "" и ``

Последние имеют полезную особенность - в них можно выводить значения переменных (как в двойных кавычках в PHP):

```javascript
    function sum(a, b) {
    return a + b;
    }

    alert( `1 + 2 = ${sum(1, 2)}.` ); // 1 + 2 = 3.
```

Также в обратных кавычках можно писать несколько строк:

```javascript
    let guestList = `Guests:
    * John
    * Pete
    * Mary
    `;

    alert(guestList); // список гостей, состоящий из нескольких строк. звездочка не является спец.символом и тоже выводится
```

Исторически '', "" были с самого начала, когда не требовался такой функционал. `` появились позже, что позволило его добавить.

Также перед \` можно написать имя "шаблонной функции", например func\`string\`. 
Нужно почитать об этом по ссылке: https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Template_literals#Tagged_template_literals

На практике такое редко применяется.

## Спецсимволы

Можно создавать многострочные string и с помощью '' и "", но потребуется спец.символ \n:

```javascript
    let guestList = "Guests:\n * John\n * Pete\n * Mary";

    alert(guestList); // список гостей, состоящий из нескольких строк
```

Будет то же самое, что и в примере с ``.

Есть другие спец.символы, таблицу сюда копировать не буду. Спец.символами также являются Юникод-символы.

Если использовать в строке тот же тип кавычки, в которую заключена строка, ее надо экранировать: \' или \":

```javascript
    alert( 'I\'m the Walrus!' ); // I'm the Walrus!
```

## Длина строки

Длина строки записана в свойстве length:

```javascript
    alert( `My\n`.length ); // 3
```

## Доступ к символам

Получить доступ к символу в строке по его номеру можно с помощью [] или charAt(), есть различие в обработке несуществующей позиции:

```javascript
    let str = `Hello`;

    // получаем первый символ
    alert( str[0] ); // H
    alert( str.charAt(0) ); // H

    // получаем последний символ
    alert( str[str.length - 1] ); // o

    alert( str[1000] ); // undefined
    alert( str.charAt(1000) ); // '' (пустая строка)
```

С помощью for..of можно посимвольно перебрать строку:

```javascript
    for (let char of "Hello") {
        alert(char); // H,e,l,l,o (char — сначала "H", потом "e", потом "l" и т. д.)
    }
```

## Строки неизменяемы

НЕЛЬЗЯ менять символы в строке, можно только записать новую с изменениями:

```javascript
    let str = 'Hi';

    str[0] = 'h'; // ошибка
    alert( str[0] ); // не работает

    str = 'h' + str[1]; // заменяем строку

    alert( str ); // hi
```

## Изменение регистра

Регистр меняется с помощью toLowerCase() и toUpperCase():

```javascript
    alert( 'Interface'.toUpperCase() ); // INTERFACE
    alert( 'Interface'.toLowerCase() ); // interface

    alert( 'Interface'[0].toLowerCase() ); // 'i'
```

## Поиск подстроки

Есть несколько способов найти подстроку:

Первый - indexOf(substr, pos). Он возвращает позицию символа, с которого начинается вхождение подстроки или -1, если ее там нет:

```javascript
    let str = 'Widget with id';

    alert( str.indexOf('Widget') ); // 0, потому что подстрока 'Widget' найдена в начале
    alert( str.indexOf('widget') ); // -1, совпадений нет, поиск чувствителен к регистру

    alert( str.indexOf("id") ); // 1, подстрока "id" найдена на позиции 1 (..idget with id)
```

В последнем примере, чтобы найти id не в слове "Widget", надо начать поиск со 2-й позиции (буква d):

```javascript
    alert( str.indexOf('id', 2) ) // 12
```
Чтобы получить все позиции вхождений, нужно запустить цикл, в котором при нахождении позиции начинаем поиск со следующей, пока не получится -1:

```javascript
    let str = 'Ослик Иа-Иа посмотрел на виадук';

    let target = 'Иа'; // цель поиска

    let pos = 0;
    while (true) {
        let foundPos = str.indexOf(target, pos);
        if (foundPos == -1) break;

        alert( `Найдено тут: ${foundPos}` );
        pos = foundPos + 1; // продолжаем со следующей позиции
    }
```
Или:

```javascript
    let str = "Ослик Иа-Иа посмотрел на виадук";
    let target = "Иа";

    let pos = -1;
    while ((pos = str.indexOf(target, pos + 1)) != -1) {
        alert( pos );
    }
```
Если хочется искать с конца строки, есть функция lastIndexOf(substr, pos).

Нужно осторожно делать проверку на вхождение подстроки. Все дело в том, что позиция 0 воспримется как false:

```javascript
    let str = "Widget with id";

    if (str.indexOf("Widget")) {
        alert("Совпадение есть"); // не работает
    }
```
А надо:

```javascript
    if (str.indexOf("Widget") != -1) {
        alert("Совпадение есть"); // теперь работает
    }
```
Есть трюк с побитовым НЕ (~). Он отбрасывает дробную часть и инвертирует все биты в 32-разрядном целом со знаком.
В итоге из n получается -(n+1), которое равно 0 только при n = -1. Это сокращает запись проверки:

```javascript
    let str = "Widget";

    if (~str.indexOf("Widget")) {
    alert( 'Совпадение есть' ); // работает
    }
```
Это неочевидный прием, но может встречаться в старом коде, поэтому нужно это понимать. 
К тому же он не работает, если строка длиннее 4294967295 символов.

## includes, startsWith, endsWith

Более надежный метод - str.includes(substr, pos), если позиция символа не интересует:

```javascript
    alert( "Widget with id".includes("Widget") ); // true

    alert( "Hello".includes("Bye") ); // false
```
Второй аргумент позволяет начать поиск с определенной позиции:

```javascript
    alert( "Midget".includes("id") ); // true
    alert( "Midget".includes("id", 3) ); // false, поиск начат с позиции 3
```
Методы str.startsWith и str.endsWith поверяют, начинается или заканчивается строка данной подстрокой:

```javascript
    alert( "Widget".startsWith("Wid") ); // true, "Widget" начинается с "Wid"
    alert( "Widget".endsWith("get") ); // true, "Widget" заканчивается на "get"
```

## Получение подстроки

В JavaScript есть 3 метода для получения подстроки: substring, substr и slice.

str.slice(start, [, end]) возвращает часть строки от start и не включая end. Если end нет, то просто - до конца:

```javascript
    let str = "stringify";
    alert( str.slice(0, 5) ); // 'strin'
    alert( str.slice(0, 1) ); // 's'
    alert( str.slice(2) ); // 'ringify'
    alert( str.slice(-4, -1) ); // 'gif', отрицательные значения указывают на отсчитывание с конца
```
str.substring(start, [, end]) возвращает часть строки между start и end:

```javascript
    let str = "stringify";
    alert( str.substring(2, 6) ); //'ring'
    alert( str.substring(6, 2) ); //'ring', то же самое
    alert( str.slice(6, 2) ); //'', для slice end должен быть больше start
```

str.substring не поддерживает отрицательные значения, они интерпретируются как 0.

str.substr(start, [, length]) возвращает часть строки от start длиной length:

```javascript
    let str = "stringify";
    alert( str.substr(2, 4) ); // 'ring'
    alert( str.substr(-4, 2) ); // 'gi', отсчитываем 4-й символ с конца и берем строку в 2 символа 
```
Из этих методов чаще всего используется slice, так как он более гибок, можно сосредоточиться на нем.
substr описан не в самой спецификации JavaScript, а в приложении к ней, в теории может не работать не в браузере. На практике же работает везде.

Строки сравниваются посимвольно в алфавитном порядке, правда есть нюансы:

```javascript
    alert( 'a' > 'Z' ); // true, строчные буквы больше заглавных
    alert( 'Österreich' > 'Zealand' ); //true, буквы с диакритическими знаками, идут "не по порядку", можно запутаться
```
Строки кодируются в UTF-16, у любого символа есть соответствующий код. 

Метод str.codePointAt(pos) возвращает код символа на позиции pos:

```javascript
    alert( "z".codePointAt(0) ); // 122
    alert( "Z".codePointAt(0) ); // 90, из-за кода заглавные буквы "меньше" строчных
```
Метод String.fromCodePoint(code) создает символ по его code:

```javascript
    alert( String.fromCodePoint(90) ); // 'Z'
```
Можно выводить юникодные символы по их коду:

```javascript
    alert( '\u005a' ); // 'Z'

    let str = '';

    for (let i = 65; i <= 220; i++) {
        str += String.fromCodePoint(i);
    }
    alert( str );
    // Выведутся символы с кодами от 65 до 220 включительно - это латинские буквы в 2 регистрах и некоторые прочие символы.
```
Ö из прошлого примера имеет код больше, чем у любой латинской буквы, поэтому при сравнении он больше.

"Правильный" алгоритм сравнения строк (по алфавиту) не такой простой, так как разные языки используют разные алфавиты.

Все современные браузеры (для IE10- нужна библиотека Intl.JS) поддерживают стандарт ECMA 402, который обеспечивает правильное сравнение строк
на разных языках.

str.localeCompare(str2) возвращает число, которое показывает какая строка больше по алфавиту в соответствии с правилами языка:

* Отрицательное, если str < str2
* Положительное, если str > str2
* 0, если строки равны

```javascript
    alert( 'Österreich'.localeCompare('Zealand') ); // -1
```
Есть 2 дополнительных аргумента: locales и options. Первый позволяет указать язык, а второй - определять дополнительные правила.
Смотреть в документации MDN.

Раздел с Юникодом добавлю позже.