В Javascript любой текст имеет тип String. Отдельного типа char для символов нет (и Symbol не для этого).

Внутренний формат для всех строк - UTF-16 вне зависимости от кодировки страницы.

Есть разные типы кавычек для строк - '', "" и ``

Последние имеют полезную особенность - в них можно выводить значения переменных (как в двойных кавычках в PHP):

    function sum(a, b) {
    return a + b;
    }

    alert( `1 + 2 = ${sum(1, 2)}.` ); // 1 + 2 = 3.

Также в обратных кавычках можно писать несколько строк:

    let guestList = `Guests:
    * John
    * Pete
    * Mary
    `;

    alert(guestList); // список гостей, состоящий из нескольких строк. звездочка не является спец.символом и тоже выводится

Исторически '', "" были с самого начала, когда не требовался такой функционал. `` появились позже, что позволило его добавить.

Также перед ` можно написать имя "шаблонной функции", например func`string`. 
Нужно почитать об этом по ссылке: https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Template_literals#Tagged_template_literals
На практике такое редко применяется.

Можно создавать многострочные string и с помощью '' и "", но потребуется спец.символ \n:

    let guestList = "Guests:\n * John\n * Pete\n * Mary";

    alert(guestList); // список гостей, состоящий из нескольких строк

Будет то же самое, что и в примере с ``.

Есть другие спец.символы, таблицу сюда копировать не буду. Спец.символами также являются Юникод-символы.

Если использовать в строке тот же тип кавычки, в которую заключена строка, ее надо экранировать: \' или \":

    alert( 'I\'m the Walrus!' ); // I'm the Walrus!

Длина строки записана в свойстве length:

    alert( `My\n`.length ); // 3

Получить доступ к символу в строке по его номеру можно с помощью [] или charAt(), есть различие в обработке несуществующей позиции:

    let str = `Hello`;

    // получаем первый символ
    alert( str[0] ); // H
    alert( str.charAt(0) ); // H

    // получаем последний символ
    alert( str[str.length - 1] ); // o

    alert( str[1000] ); // undefined
    alert( str.charAt(1000) ); // '' (пустая строка)

С помощью for..of можно посимвольно перебрать строку:

    for (let char of "Hello") {
        alert(char); // H,e,l,l,o (char — сначала "H", потом "e", потом "l" и т. д.)
    }

НЕЛЬЗЯ менять символы в строке, можно только записать новую с изменениями:

    let str = 'Hi';

    str[0] = 'h'; // ошибка
    alert( str[0] ); // не работает

    str = 'h' + str[1]; // заменяем строку

    alert( str ); // hi

Регистр меняется с помощью toLowerCase() и toUpperCase():

    alert( 'Interface'.toUpperCase() ); // INTERFACE
    alert( 'Interface'.toLowerCase() ); // interface

    alert( 'Interface'[0].toLowerCase() ); // 'i'

Есть несколько способов найти подстроку:

Первый - indexOf(substr, pos). Он возвращает позицию символа, с которого начинается вхождение подстроки или -1, если ее там нет:

    let str = 'Widget with id';

    alert( str.indexOf('Widget') ); // 0, потому что подстрока 'Widget' найдена в начале
    alert( str.indexOf('widget') ); // -1, совпадений нет, поиск чувствителен к регистру

    alert( str.indexOf("id") ); // 1, подстрока "id" найдена на позиции 1 (..idget with id)

В последнем примере, чтобы найти id не в слове "Widget", надо начать поиск со 2-й позиции (буква d):

    alert( str.indexOf('id', 2) ) // 12

Чтобы получить все позиции вхождений, нужно запустить цикл, в котором при нахождении позиции начинаем поиск со следующей, пока не получится -1:

    let str = 'Ослик Иа-Иа посмотрел на виадук';

    let target = 'Иа'; // цель поиска

    let pos = 0;
    while (true) {
        let foundPos = str.indexOf(target, pos);
        if (foundPos == -1) break;

        alert( `Найдено тут: ${foundPos}` );
        pos = foundPos + 1; // продолжаем со следующей позиции
    }

Или:

    let str = "Ослик Иа-Иа посмотрел на виадук";
    let target = "Иа";

    let pos = -1;
    while ((pos = str.indexOf(target, pos + 1)) != -1) {
        alert( pos );
    }

Если хочется искать с конца строки, есть функция lastIndexOf(substr, pos).

Нужно осторожно делать проверку на вхождение подстроки. Все дело в том, что позиция 0 воспримется как false:

    let str = "Widget with id";

    if (str.indexOf("Widget")) {
        alert("Совпадение есть"); // не работает
    }

А надо:

    if (str.indexOf("Widget") != -1) {
        alert("Совпадение есть"); // теперь работает
    }

Есть трюк с побитовым НЕ (~). Он отбрасывает дробную часть и инвертирует все биты в 32-разрядном целом со знаком.
В итоге из n получается -(n+1), которое равно 0 только при n = -1. Это сокращает запись проверки:

    let str = "Widget";

    if (~str.indexOf("Widget")) {
    alert( 'Совпадение есть' ); // работает
    }

Это неочевидный прием, но может встречаться в старом коде, поэтому нужно это понимать. 
К тому же он не работает, если строка длиннее 4294967295 символов.

Более надежный метод - str.includes(substr, pos), если позиция символа не интересует:

    alert( "Widget with id".includes("Widget") ); // true

    alert( "Hello".includes("Bye") ); // false

Второй аргумент позволяет начать поиск с определенной позиции:

    alert( "Midget".includes("id") ); // true
    alert( "Midget".includes("id", 3) ); // false, поиск начат с позиции 3

Конспект допишу позже.