# Методы массивов

У массивов есть множество методов. Ниже они разбиты на группы.

## Добавление/удаление элементов

Есть методы, добавляющие/удаляющие элементы в начале или в конце:

* arr.push(...items) - добавляет в конец
* arr.pop() - выводит элемент из конца и удаляет его
* arr.shift() - выводит элемент из начала и удаляет его
* arr.unshift(...items) - добавляет в начало

### splice

Удалить элемент из массива, как и из объекта, можно с помощью delete:

```javascript
let arr = ["I", "go", "home"];

delete arr[1]; // удалить "go"

alert( arr[1] ); // undefined

// теперь arr = ["I",  , "home"];
alert( arr.length ); // 3
```

В итоге все равно в массиве 3 элемента, но один из них undefined. Так как это массив, нам нужно сдвинуть элементы, чтобы заполнить пустоту.

Для этого есть метод arr.splice(str), он умеет добавлять, удалять и заменять элементы.

    arr.splice(index[, deleteCount, elem1, ..., elemN])

Метод ведет отсчет с позиции index, удаляет количество элементов deleteCount и вставляет на их место произвольное количество элементов.

Удалим 3 элемента и заменим их двумя другими:

```javascript
let arr = ["Я", "изучаю", "JavaScript", "прямо", "сейчас"];

// удалить 3 первых элемента и заменить их другими
arr.splice(0, 3, "Давай", "танцевать");

alert( arr ) // теперь ["Давай", "танцевать", "прямо", "сейчас"]
```

Метод splice возвращает массив из удаленных элементов (пригодится):

```javascript
let arr = ["Я", "изучаю", "JavaScript", "прямо", "сейчас"];

// удалить 2 первых элемента
let removed = arr.splice(0, 2);

alert( removed ); // "Я", "изучаю" <-- массив из удалённых элементов
```

Если установить deleteCount в 0, просто будет добавление:

```javascript
let arr = ["Я", "изучаю", "JavaScript"];

// с позиции 2
// удалить 0 элементов
// вставить "сложный", "язык"
arr.splice(2, 0, "сложный", "язык");

alert( arr ); // "Я", "изучаю", "сложный", "язык", "JavaScript"
```

Если поставить отрицательный index, то отсчет будет вестись с конца, как в строках:

```javascript
let arr = [1, 2, 5];

// начиная с индекса -1 (перед последним элементом)
// удалить 0 элементов,
// затем вставить числа 3 и 4
arr.splice(-1, 0, 3, 4);

alert( arr ); // 1,2,3,4,5
```

### slice

Метод arr.slice - это урезанный splice:

    arr.slice(start, end)

Он возвращает новый массив, в который входят элементы, со start и до end не включительно. Индексы также могут быть отрицательными. Если нет end, то просто до конца.

```javascript
let arr = ["t", "e", "s", "t"];

alert( arr.slice(1, 3) ); // e,s (копирует с 1 по 3)

alert( arr.slice(-2) ); // s,t (копирует с -2 до конца)
```

### concat

Метод arr.concat создает новый массив, в который копирует данные из других массивов, а также дополнительные значения.

    arr.concat(arg1, arg2...)

arg может быть как массивом, так и обычным значением.

```javascript
let arr = [1, 2];

// создать массив из: arr и [3,4]
alert( arr.concat([3, 4])); // 1,2,3,4

// создать массив из: arr и [3,4] и [5,6]
alert( arr.concat([3, 4], [5, 6])); // 1,2,3,4,5,6

// создать массив из: arr и [3,4], потом добавить значения 5 и 6
alert( arr.concat([3, 4], 5, 6)); // 1,2,3,4,5,6
```

Объекты, пусть и похожи на массивы, добавятся как обычные значения:

```javascript
let arr = [1, 2];

let arrayLike = {
  0: "что-то",
  length: 1
};

alert( arr.concat(arrayLike) ); // 1,2,[object Object]
```

Но это можно исправить с помощью свойства Symbol.isConcatSpreadable, что позволяет обрабатывать объект как массив с помощью concat:

```javascript
let arr = [1, 2];

let arrayLike = {
  0: "что-то",
  1: "ещё",
  [Symbol.isConcatSpreadable]: true,
  length: 2 
};

alert( arr.concat(arrayLike) ); // 1,2,что-то,ещё
```

## Перебор: forEach

arr.forEach запускает функцию для каждого элемента массива

    arr.forEach(function(item, index, array) {
      // ... делать что-то с item
    });

Наглядно тут:

```javascript
["Bilbo", "Gandalf", "Nazgul"].forEach((item, index, array) => {
  alert(`${item} имеет позицию ${index} в ${array}`);
});
```

Здесь просто alert-ом выводятся все элементы по очереди:

```javascript
// Вызов alert для каждого элемента
["Bilbo", "Gandalf", "Nazgul"].forEach(alert);
```

Результат самой функции отбрасывается и игнорируется.

## Поиск в массиве

Рассмотрим методы для поиска чего-то в массиве.

### indexOf/lastIndexOf и includes

Работают с элементами в массиве как с символами в строке:

* arr.indexOf(item, from) ищет item, начиная с индекса from, и возвращает индекс, на котором был найден искомый элемент, в противном случае -1.
* arr.lastIndexOf(item, from) – то же самое, но ищет справа налево.
* arr.includes(item, from) – ищет item, начиная с индекса from, и возвращает true, если поиск успешен.

Например:

```javascript
let arr = [1, 0, false];

alert( arr.indexOf(0) ); // 1
alert( arr.indexOf(false) ); // 2
alert( arr.indexOf(null) ); // -1

alert( arr.includes(1) ); // true
```

Методы используют строгое сравнение (===), то есть если мы ищем false, мы не находим 0.

Незначительная особенность includes в том, что он правильно обрабатывает NaN:

```javascript
const arr = [NaN];
alert( arr.indexOf(NaN) ); // -1 (должен быть 0, но === проверка на равенство не работает для NaN)
alert( arr.includes(NaN) );// true (верно)
```

### find и findIndex

С помощью arr.find можно искать элементы в массиве объектов по определенному условию:

```javascript
let result = arr.find(function(item, index, array) {
  // если true - возвращается текущий элемент и перебор прерывается
  // если все итерации оказались ложными возвращается undefined
});
```

Пример:

```javascript
let users = [
  {id: 1, name: "Вася"},
  {id: 2, name: "Петя"},
  {id: 3, name: "Маша"}
];

let user = users.find(item => item.id == 1);

alert(user.name); // Вася
```

Аргументы кроме item используются редко, поэтому можно писать функцию в форме выше.

findIndex возвращает index вместо элемента или -1, если ничего не найдено.

### filter

arr.filter в отличие от find возвращает все найденные элементы, а не первый из них, а в остальном работает так же:

```javascript
let users = [
  {id: 1, name: "Вася"},
  {id: 2, name: "Петя"},
  {id: 3, name: "Маша"}
];

// возвращает массив, состоящий из двух первых пользователей
let someUsers = users.filter(item => item.id < 3);

alert(someUsers.length); // 2
```

## Преобразование массива

Перейдем к методам преобразования и упорядочения массива.

### map

Метод arr.map полезен и используется очень часто. Он вызывает функцию для каждого элемента и возвращает массив значений этих функций.

```js
let result = arr.map(function(item, index, array) {
  // возвращается новое значение вместо элемента
});
```

Преобразуем каждый элемент в его длину:

```js
let lengths = ["Bilbo", "Gandalf", "Nazgul"].map(item => item.length);
alert(lengths); // 5,7,6
```

### sort(fn)

Метод arr.sort сортирует массив, при этом сам массив изменяется (мутирует).

```js
let arr = [ 1, 2, 15 ];

// метод сортирует содержимое arr
arr.sort();

alert( arr );  // 1, 15, 2
```

Сортировка происходит как у строк, поэтому '15' < '2'.

Чтобы это предотвратить, нужно использовать собственную функцию для сортировки, в качестве аргумента для arr.sort(fn).

```js
function compare(a, b) {
  if (a > b) return 1; // если первое значение больше второго
  if (a == b) return 0; // если равны
  if (a < b) return -1; // если первое значение меньше второго
}
```

## Конспект будет дописан позже